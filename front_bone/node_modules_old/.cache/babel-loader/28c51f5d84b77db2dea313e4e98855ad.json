{"ast":null,"code":"import _possibleConstructorReturn from \"/home/ayaz/Projects/boosthub.com/front_bone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/ayaz/Projects/boosthub.com/front_bone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/ayaz/Projects/boosthub.com/front_bone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _toConsumableArray from \"/home/ayaz/Projects/boosthub.com/front_bone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/home/ayaz/Projects/boosthub.com/front_bone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/ayaz/Projects/boosthub.com/front_bone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/ayaz/Projects/boosthub.com/front_bone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { Annotation, EditorSelection, codePointAt, codePointSize, fromCodePoint, Facet, combineConfig, StateEffect, StateField, Prec, Text, MapMode, RangeValue, RangeSet, CharCategory } from '@codemirror/state';\nimport { logException, Direction, showTooltip, EditorView, ViewPlugin, getTooltip, Decoration, WidgetType, keymap } from '@codemirror/view';\nimport { syntaxTree, indentUnit } from '@codemirror/language';\n/**\nAn instance of this is passed to completion source functions.\n*/\n\nvar CompletionContext = /*#__PURE__*/function () {\n  /**\n  Create a new completion context. (Mostly useful for testing\n  completion sources—in the editor, the extension will create\n  these for you.)\n  */\n  function CompletionContext(\n  /**\n  The editor state that the completion happens in.\n  */\n  state,\n  /**\n  The position at which the completion is happening.\n  */\n  pos,\n  /**\n  Indicates whether completion was activated explicitly, or\n  implicitly by typing. The usual way to respond to this is to\n  only return completions when either there is part of a\n  completable entity before the cursor, or `explicit` is true.\n  */\n  explicit) {\n    _classCallCheck(this, CompletionContext);\n\n    this.state = state;\n    this.pos = pos;\n    this.explicit = explicit;\n    /**\n    @internal\n    */\n\n    this.abortListeners = [];\n  }\n  /**\n  Get the extent, content, and (if there is a token) type of the\n  token before `this.pos`.\n  */\n\n\n  _createClass(CompletionContext, [{\n    key: \"tokenBefore\",\n    value: function tokenBefore(types) {\n      var token = syntaxTree(this.state).resolveInner(this.pos, -1);\n\n      while (token && types.indexOf(token.name) < 0) {\n        token = token.parent;\n      }\n\n      return token ? {\n        from: token.from,\n        to: this.pos,\n        text: this.state.sliceDoc(token.from, this.pos),\n        type: token.type\n      } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */\n\n  }, {\n    key: \"matchBefore\",\n    value: function matchBefore(expr) {\n      var line = this.state.doc.lineAt(this.pos);\n      var start = Math.max(line.from, this.pos - 250);\n      var str = line.text.slice(start - line.from, this.pos - line.from);\n      var found = str.search(ensureAnchor(expr, false));\n      return found < 0 ? null : {\n        from: start + found,\n        to: this.pos,\n        text: str.slice(found)\n      };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */\n\n  }, {\n    key: \"addEventListener\",\n\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    */\n    value: function addEventListener(type, listener) {\n      if (type == \"abort\" && this.abortListeners) this.abortListeners.push(listener);\n    }\n  }, {\n    key: \"aborted\",\n    get: function get() {\n      return this.abortListeners == null;\n    }\n  }]);\n\n  return CompletionContext;\n}();\n\nfunction toSet(chars) {\n  var flat = Object.keys(chars).join(\"\");\n  var words = /\\w/.test(flat);\n  if (words) flat = flat.replace(/\\w/g, \"\");\n  return \"[\".concat(words ? \"\\\\w\" : \"\").concat(flat.replace(/[^\\w\\s]/g, \"\\\\$&\"), \"]\");\n}\n\nfunction prefixMatch(options) {\n  var first = Object.create(null),\n      rest = Object.create(null);\n\n  var _iterator = _createForOfIteratorHelper(options),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var label = _step.value.label;\n      first[label[0]] = true;\n\n      for (var i = 1; i < label.length; i++) {\n        rest[label[i]] = true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var source = toSet(first) + toSet(rest) + \"*$\";\n  return [new RegExp(\"^\" + source), new RegExp(source)];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/\n\n\nfunction completeFromList(list) {\n  var options = list.map(function (o) {\n    return typeof o == \"string\" ? {\n      label: o\n    } : o;\n  });\n\n  var _ref = options.every(function (o) {\n    return /^\\w+$/.test(o.label);\n  }) ? [/\\w*$/, /\\w+$/] : prefixMatch(options),\n      _ref2 = _slicedToArray(_ref, 2),\n      validFor = _ref2[0],\n      match = _ref2[1];\n\n  return function (context) {\n    var token = context.matchBefore(match);\n    return token || context.explicit ? {\n      from: token ? token.from : context.pos,\n      options: options,\n      validFor: validFor\n    } : null;\n  };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/\n\n\nfunction ifIn(nodes, source) {\n  return function (context) {\n    for (var pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {\n      if (nodes.indexOf(pos.name) > -1) return source(context);\n    }\n\n    return null;\n  };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/\n\n\nfunction ifNotIn(nodes, source) {\n  return function (context) {\n    for (var pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {\n      if (nodes.indexOf(pos.name) > -1) return null;\n    }\n\n    return source(context);\n  };\n}\n\nvar Option = function Option(completion, source, match) {\n  _classCallCheck(this, Option);\n\n  this.completion = completion;\n  this.source = source;\n  this.match = match;\n};\n\nfunction cur(state) {\n  return state.selection.main.head;\n} // Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\n\n\nfunction ensureAnchor(expr, start) {\n  var _a;\n\n  var source = expr.source;\n  var addStart = start && source[0] != \"^\",\n      addEnd = source[source.length - 1] != \"$\";\n  if (!addStart && !addEnd) return expr;\n  return new RegExp(\"\".concat(addStart ? \"^\" : \"\", \"(?:\").concat(source, \")\").concat(addEnd ? \"$\" : \"\"), (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? \"i\" : \"\");\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/\n\n\nvar pickedCompletion = /*@__PURE__*/Annotation.define();\n/**\nHelper function that returns a transaction spec which inserts a\ncompletion's text in the main selection range, and any other\nselection range that has the same text in front of it.\n*/\n\nfunction insertCompletionText(state, text, from, to) {\n  return Object.assign(Object.assign({}, state.changeByRange(function (range) {\n    if (range == state.selection.main) return {\n      changes: {\n        from: from,\n        to: to,\n        insert: text\n      },\n      range: EditorSelection.cursor(from + text.length)\n    };\n    var len = to - from;\n    if (!range.empty || len && state.sliceDoc(range.from - len, range.from) != state.sliceDoc(from, to)) return {\n      range: range\n    };\n    return {\n      changes: {\n        from: range.from - len,\n        to: range.from,\n        insert: text\n      },\n      range: EditorSelection.cursor(range.from - len + text.length)\n    };\n  })), {\n    userEvent: \"input.complete\"\n  });\n}\n\nfunction applyCompletion(view, option) {\n  var apply = option.completion.apply || option.completion.label;\n  var result = option.source;\n  if (typeof apply == \"string\") view.dispatch(insertCompletionText(view.state, apply, result.from, result.to));else apply(view, option.completion, result.from, result.to);\n}\n\nvar SourceCache = /*@__PURE__*/new WeakMap();\n\nfunction asSource(source) {\n  if (!Array.isArray(source)) return source;\n  var known = SourceCache.get(source);\n  if (!known) SourceCache.set(source, known = completeFromList(source));\n  return known;\n} // A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\n\n\nvar FuzzyMatcher = /*#__PURE__*/function () {\n  function FuzzyMatcher(pattern) {\n    _classCallCheck(this, FuzzyMatcher);\n\n    this.pattern = pattern;\n    this.chars = [];\n    this.folded = []; // Buffers reused by calls to `match` to track matched character\n    // positions.\n\n    this.any = [];\n    this.precise = [];\n    this.byWord = [];\n\n    for (var p = 0; p < pattern.length;) {\n      var char = codePointAt(pattern, p),\n          size = codePointSize(char);\n      this.chars.push(char);\n      var part = pattern.slice(p, p + size),\n          upper = part.toUpperCase();\n      this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));\n      p += size;\n    }\n\n    this.astral = pattern.length != this.chars.length;\n  } // Matches a given word (completion) against the pattern (input).\n  // Will return null for no match, and otherwise an array that starts\n  // with the match score, followed by any number of `from, to` pairs\n  // indicating the matched parts of `word`.\n  //\n  // The score is a number that is more negative the worse the match\n  // is. See `Penalty` above.\n\n\n  _createClass(FuzzyMatcher, [{\n    key: \"match\",\n    value: function match(word) {\n      if (this.pattern.length == 0) return [0];\n      if (word.length < this.pattern.length) return null;\n      var chars = this.chars,\n          folded = this.folded,\n          any = this.any,\n          precise = this.precise,\n          byWord = this.byWord; // For single-character queries, only match when they occur right\n      // at the start\n\n      if (chars.length == 1) {\n        var first = codePointAt(word, 0);\n        return first == chars[0] ? [0, 0, codePointSize(first)] : first == folded[0] ? [-200\n        /* CaseFold */\n        , 0, codePointSize(first)] : null;\n      }\n\n      var direct = word.indexOf(this.pattern);\n      if (direct == 0) return [0, 0, this.pattern.length];\n      var len = chars.length,\n          anyTo = 0;\n\n      if (direct < 0) {\n        for (var i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\n          var next = codePointAt(word, i);\n          if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;\n          i += codePointSize(next);\n        } // No match, exit immediately\n\n\n        if (anyTo < len) return null;\n      } // This tracks the extent of the precise (non-folded, not\n      // necessarily adjacent) match\n\n\n      var preciseTo = 0; // Tracks whether there is a match that hits only characters that\n      // appear to be starting words. `byWordFolded` is set to true when\n      // a case folded character is encountered in such a match\n\n      var byWordTo = 0,\n          byWordFolded = false; // If we've found a partial adjacent match, these track its state\n\n      var adjacentTo = 0,\n          adjacentStart = -1,\n          adjacentEnd = -1;\n      var hasLower = /[a-z]/.test(word),\n          wordAdjacent = true; // Go over the option's text, scanning for the various kinds of matches\n\n      for (var _i = 0, _e = Math.min(word.length, 200), prevType = 0\n      /* NonWord */\n      ; _i < _e && byWordTo < len;) {\n        var _next = codePointAt(word, _i);\n\n        if (direct < 0) {\n          if (preciseTo < len && _next == chars[preciseTo]) precise[preciseTo++] = _i;\n\n          if (adjacentTo < len) {\n            if (_next == chars[adjacentTo] || _next == folded[adjacentTo]) {\n              if (adjacentTo == 0) adjacentStart = _i;\n              adjacentEnd = _i + 1;\n              adjacentTo++;\n            } else {\n              adjacentTo = 0;\n            }\n          }\n        }\n\n        var ch = void 0,\n            type = _next < 0xff ? _next >= 48 && _next <= 57 || _next >= 97 && _next <= 122 ? 2\n        /* Lower */\n        : _next >= 65 && _next <= 90 ? 1\n        /* Upper */\n        : 0\n        /* NonWord */\n        : (ch = fromCodePoint(_next)) != ch.toLowerCase() ? 1\n        /* Upper */\n        : ch != ch.toUpperCase() ? 2\n        /* Lower */\n        : 0\n        /* NonWord */\n        ;\n\n        if (!_i || type == 1\n        /* Upper */\n        && hasLower || prevType == 0\n        /* NonWord */\n        && type != 0\n        /* NonWord */\n        ) {\n          if (chars[byWordTo] == _next || folded[byWordTo] == _next && (byWordFolded = true)) byWord[byWordTo++] = _i;else if (byWord.length) wordAdjacent = false;\n        }\n\n        prevType = type;\n        _i += codePointSize(_next);\n      }\n\n      if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100\n      /* ByWord */\n      + (byWordFolded ? -200\n      /* CaseFold */\n      : 0), byWord, word);\n      if (adjacentTo == len && adjacentStart == 0) return [-200\n      /* CaseFold */\n      - word.length, 0, adjacentEnd];\n      if (direct > -1) return [-700\n      /* NotStart */\n      - word.length, direct, direct + this.pattern.length];\n      if (adjacentTo == len) return [-200\n      /* CaseFold */\n      + -700\n      /* NotStart */\n      - word.length, adjacentStart, adjacentEnd];\n      if (byWordTo == len) return this.result(-100\n      /* ByWord */\n      + (byWordFolded ? -200\n      /* CaseFold */\n      : 0) + -700\n      /* NotStart */\n      + (wordAdjacent ? 0 : -1100\n      /* Gap */\n      ), byWord, word);\n      return chars.length == 2 ? null : this.result((any[0] ? -700\n      /* NotStart */\n      : 0) + -200\n      /* CaseFold */\n      + -1100\n      /* Gap */\n      , any, word);\n    }\n  }, {\n    key: \"result\",\n    value: function result(score, positions, word) {\n      var result = [score - word.length],\n          i = 1;\n\n      var _iterator2 = _createForOfIteratorHelper(positions),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var pos = _step2.value;\n          var to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);\n          if (i > 1 && result[i - 1] == pos) result[i - 1] = to;else {\n            result[i++] = pos;\n            result[i++] = to;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return result;\n    }\n  }]);\n\n  return FuzzyMatcher;\n}();\n\nvar completionConfig = /*@__PURE__*/Facet.define({\n  combine: function combine(configs) {\n    return combineConfig(configs, {\n      activateOnTyping: true,\n      selectOnOpen: true,\n      override: null,\n      closeOnBlur: true,\n      maxRenderedOptions: 100,\n      defaultKeymap: true,\n      optionClass: function optionClass() {\n        return \"\";\n      },\n      aboveCursor: false,\n      icons: true,\n      addToOptions: [],\n      compareCompletions: function compareCompletions(a, b) {\n        return a.label.localeCompare(b.label);\n      }\n    }, {\n      defaultKeymap: function defaultKeymap(a, b) {\n        return a && b;\n      },\n      closeOnBlur: function closeOnBlur(a, b) {\n        return a && b;\n      },\n      icons: function icons(a, b) {\n        return a && b;\n      },\n      optionClass: function optionClass(a, b) {\n        return function (c) {\n          return joinClass(a(c), b(c));\n        };\n      },\n      addToOptions: function addToOptions(a, b) {\n        return a.concat(b);\n      }\n    });\n  }\n});\n\nfunction joinClass(a, b) {\n  return a ? b ? a + \" \" + b : a : b;\n}\n\nfunction optionContent(config) {\n  var content = config.addToOptions.slice();\n  if (config.icons) content.push({\n    render: function render(completion) {\n      var _icon$classList;\n\n      var icon = document.createElement(\"div\");\n      icon.classList.add(\"cm-completionIcon\");\n      if (completion.type) (_icon$classList = icon.classList).add.apply(_icon$classList, _toConsumableArray(completion.type.split(/\\s+/g).map(function (cls) {\n        return \"cm-completionIcon-\" + cls;\n      })));\n      icon.setAttribute(\"aria-hidden\", \"true\");\n      return icon;\n    },\n    position: 20\n  });\n  content.push({\n    render: function render(completion, _s, match) {\n      var labelElt = document.createElement(\"span\");\n      labelElt.className = \"cm-completionLabel\";\n      var label = completion.label,\n          off = 0;\n\n      for (var j = 1; j < match.length;) {\n        var from = match[j++],\n            to = match[j++];\n        if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n        var span = labelElt.appendChild(document.createElement(\"span\"));\n        span.appendChild(document.createTextNode(label.slice(from, to)));\n        span.className = \"cm-completionMatchedText\";\n        off = to;\n      }\n\n      if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));\n      return labelElt;\n    },\n    position: 50\n  }, {\n    render: function render(completion) {\n      if (!completion.detail) return null;\n      var detailElt = document.createElement(\"span\");\n      detailElt.className = \"cm-completionDetail\";\n      detailElt.textContent = completion.detail;\n      return detailElt;\n    },\n    position: 80\n  });\n  return content.sort(function (a, b) {\n    return a.position - b.position;\n  }).map(function (a) {\n    return a.render;\n  });\n}\n\nfunction rangeAroundSelected(total, selected, max) {\n  if (total <= max) return {\n    from: 0,\n    to: total\n  };\n  if (selected < 0) selected = 0;\n\n  if (selected <= total >> 1) {\n    var _off = Math.floor(selected / max);\n\n    return {\n      from: _off * max,\n      to: (_off + 1) * max\n    };\n  }\n\n  var off = Math.floor((total - selected) / max);\n  return {\n    from: total - (off + 1) * max,\n    to: total - off * max\n  };\n}\n\nvar CompletionTooltip = /*#__PURE__*/function () {\n  function CompletionTooltip(view, stateField) {\n    var _this = this;\n\n    _classCallCheck(this, CompletionTooltip);\n\n    this.view = view;\n    this.stateField = stateField;\n    this.info = null;\n    this.placeInfo = {\n      read: function read() {\n        return _this.measureInfo();\n      },\n      write: function write(pos) {\n        return _this.positionInfo(pos);\n      },\n      key: this\n    };\n    var cState = view.state.field(stateField);\n    var _cState$open = cState.open,\n        options = _cState$open.options,\n        selected = _cState$open.selected;\n    var config = view.state.facet(completionConfig);\n    this.optionContent = optionContent(config);\n    this.optionClass = config.optionClass;\n    this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-tooltip-autocomplete\";\n    this.dom.addEventListener(\"mousedown\", function (e) {\n      for (var dom = e.target, match; dom && dom != _this.dom; dom = dom.parentNode) {\n        if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n          applyCompletion(view, options[+match[1]]);\n          e.preventDefault();\n          return;\n        }\n      }\n    });\n    this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));\n    this.list.addEventListener(\"scroll\", function () {\n      if (_this.info) _this.view.requestMeasure(_this.placeInfo);\n    });\n  }\n\n  _createClass(CompletionTooltip, [{\n    key: \"mount\",\n    value: function mount() {\n      this.updateSel();\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update) {\n      if (_update.state.field(this.stateField) != _update.startState.field(this.stateField)) this.updateSel();\n    }\n  }, {\n    key: \"positioned\",\n    value: function positioned() {\n      if (this.info) this.view.requestMeasure(this.placeInfo);\n    }\n  }, {\n    key: \"updateSel\",\n    value: function updateSel() {\n      var _this2 = this;\n\n      var cState = this.view.state.field(this.stateField),\n          open = cState.open;\n\n      if (open.selected < this.range.from || open.selected >= this.range.to) {\n        this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n        this.list.remove();\n        this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));\n        this.list.addEventListener(\"scroll\", function () {\n          if (_this2.info) _this2.view.requestMeasure(_this2.placeInfo);\n        });\n      }\n\n      if (this.updateSelectedOption(open.selected)) {\n        if (this.info) {\n          this.info.remove();\n          this.info = null;\n        }\n\n        var completion = open.options[open.selected].completion;\n        var info = completion.info;\n        if (!info) return;\n        var infoResult = typeof info === 'string' ? document.createTextNode(info) : info(completion);\n        if (!infoResult) return;\n\n        if ('then' in infoResult) {\n          infoResult.then(function (node) {\n            if (node && _this2.view.state.field(_this2.stateField, false) == cState) _this2.addInfoPane(node);\n          }).catch(function (e) {\n            return logException(_this2.view.state, e, \"completion info\");\n          });\n        } else {\n          this.addInfoPane(infoResult);\n        }\n      }\n    }\n  }, {\n    key: \"addInfoPane\",\n    value: function addInfoPane(content) {\n      var dom = this.info = document.createElement(\"div\");\n      dom.className = \"cm-tooltip cm-completionInfo\";\n      dom.appendChild(content);\n      this.dom.appendChild(dom);\n      this.view.requestMeasure(this.placeInfo);\n    }\n  }, {\n    key: \"updateSelectedOption\",\n    value: function updateSelectedOption(selected) {\n      var set = null;\n\n      for (var opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\n        if (i == selected) {\n          if (!opt.hasAttribute(\"aria-selected\")) {\n            opt.setAttribute(\"aria-selected\", \"true\");\n            set = opt;\n          }\n        } else {\n          if (opt.hasAttribute(\"aria-selected\")) opt.removeAttribute(\"aria-selected\");\n        }\n      }\n\n      if (set) scrollIntoView(this.list, set);\n      return set;\n    }\n  }, {\n    key: \"measureInfo\",\n    value: function measureInfo() {\n      var sel = this.dom.querySelector(\"[aria-selected]\");\n      if (!sel || !this.info) return null;\n      var listRect = this.dom.getBoundingClientRect();\n      var infoRect = this.info.getBoundingClientRect();\n      var selRect = sel.getBoundingClientRect();\n      if (selRect.top > Math.min(innerHeight, listRect.bottom) - 10 || selRect.bottom < Math.max(0, listRect.top) + 10) return null;\n      var top = Math.max(0, Math.min(selRect.top, innerHeight - infoRect.height)) - listRect.top;\n      var left = this.view.textDirection == Direction.RTL;\n      var spaceLeft = listRect.left,\n          spaceRight = innerWidth - listRect.right;\n      if (left && spaceLeft < Math.min(infoRect.width, spaceRight)) left = false;else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft)) left = true;\n      return {\n        top: top,\n        left: left\n      };\n    }\n  }, {\n    key: \"positionInfo\",\n    value: function positionInfo(pos) {\n      if (this.info) {\n        this.info.style.top = (pos ? pos.top : -1e6) + \"px\";\n\n        if (pos) {\n          this.info.classList.toggle(\"cm-completionInfo-left\", pos.left);\n          this.info.classList.toggle(\"cm-completionInfo-right\", !pos.left);\n        }\n      }\n    }\n  }, {\n    key: \"createListBox\",\n    value: function createListBox(options, id, range) {\n      var ul = document.createElement(\"ul\");\n      ul.id = id;\n      ul.setAttribute(\"role\", \"listbox\");\n      ul.setAttribute(\"aria-expanded\", \"true\");\n      ul.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\n\n      for (var i = range.from; i < range.to; i++) {\n        var _options$i = options[i],\n            completion = _options$i.completion,\n            match = _options$i.match;\n        var li = ul.appendChild(document.createElement(\"li\"));\n        li.id = id + \"-\" + i;\n        li.setAttribute(\"role\", \"option\");\n        var cls = this.optionClass(completion);\n        if (cls) li.className = cls;\n\n        var _iterator3 = _createForOfIteratorHelper(this.optionContent),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var source = _step3.value;\n            var node = source(completion, this.view.state, match);\n            if (node) li.appendChild(node);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      if (range.from) ul.classList.add(\"cm-completionListIncompleteTop\");\n      if (range.to < options.length) ul.classList.add(\"cm-completionListIncompleteBottom\");\n      return ul;\n    }\n  }]);\n\n  return CompletionTooltip;\n}(); // We allocate a new function instance every time the completion\n// changes to force redrawing/repositioning of the tooltip\n\n\nfunction completionTooltip(stateField) {\n  return function (view) {\n    return new CompletionTooltip(view, stateField);\n  };\n}\n\nfunction scrollIntoView(container, element) {\n  var parent = container.getBoundingClientRect();\n  var self = element.getBoundingClientRect();\n  if (self.top < parent.top) container.scrollTop -= parent.top - self.top;else if (self.bottom > parent.bottom) container.scrollTop += self.bottom - parent.bottom;\n} // Used to pick a preferred option when two options with the same\n// label occur in the result.\n\n\nfunction score(option) {\n  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);\n}\n\nfunction sortOptions(active, state) {\n  var options = [],\n      i = 0;\n\n  var _iterator4 = _createForOfIteratorHelper(active),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var a = _step4.value;\n\n      if (a.hasResult()) {\n        if (a.result.filter === false) {\n          var getMatch = a.result.getMatch;\n\n          var _iterator6 = _createForOfIteratorHelper(a.result.options),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var option = _step6.value;\n              var match = [1e9 - i++];\n\n              if (getMatch) {\n                var _iterator7 = _createForOfIteratorHelper(getMatch(option)),\n                    _step7;\n\n                try {\n                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                    var n = _step7.value;\n                    match.push(n);\n                  }\n                } catch (err) {\n                  _iterator7.e(err);\n                } finally {\n                  _iterator7.f();\n                }\n              }\n\n              options.push(new Option(option, a, match));\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        } else {\n          var matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)),\n              _match = void 0;\n\n          var _iterator8 = _createForOfIteratorHelper(a.result.options),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _option = _step8.value;\n\n              if (_match = matcher.match(_option.label)) {\n                if (_option.boost != null) _match[0] += _option.boost;\n                options.push(new Option(_option, a, _match));\n              }\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  var result = [],\n      prev = null;\n  var compare = state.facet(completionConfig).compareCompletions;\n\n  var _iterator5 = _createForOfIteratorHelper(options.sort(function (a, b) {\n    return b.match[0] - a.match[0] || compare(a.completion, b.completion);\n  })),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var opt = _step5.value;\n      if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != null && opt.completion.type != null && prev.type != opt.completion.type || prev.apply != opt.completion.apply) result.push(opt);else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;\n      prev = opt.completion;\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return result;\n}\n\nvar CompletionDialog = /*#__PURE__*/function () {\n  function CompletionDialog(options, attrs, tooltip, timestamp, selected) {\n    _classCallCheck(this, CompletionDialog);\n\n    this.options = options;\n    this.attrs = attrs;\n    this.tooltip = tooltip;\n    this.timestamp = timestamp;\n    this.selected = selected;\n  }\n\n  _createClass(CompletionDialog, [{\n    key: \"setSelected\",\n    value: function setSelected(selected, id) {\n      return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected);\n    }\n  }, {\n    key: \"map\",\n    value: function map(changes) {\n      return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {\n        pos: changes.mapPos(this.tooltip.pos)\n      }), this.timestamp, this.selected);\n    }\n  }], [{\n    key: \"build\",\n    value: function build(active, state, id, prev, conf) {\n      var options = sortOptions(active, state);\n      if (!options.length) return null;\n      var selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;\n\n      if (prev && prev.selected != selected && prev.selected != -1) {\n        var selectedValue = prev.options[prev.selected].completion;\n\n        for (var i = 0; i < options.length; i++) {\n          if (options[i].completion == selectedValue) {\n            selected = i;\n            break;\n          }\n        }\n      }\n\n      return new CompletionDialog(options, makeAttrs(id, selected), {\n        pos: active.reduce(function (a, b) {\n          return b.hasResult() ? Math.min(a, b.from) : a;\n        }, 1e8),\n        create: completionTooltip(completionState),\n        above: conf.aboveCursor\n      }, prev ? prev.timestamp : Date.now(), selected);\n    }\n  }]);\n\n  return CompletionDialog;\n}();\n\nvar CompletionState = /*#__PURE__*/function () {\n  function CompletionState(active, id, open) {\n    _classCallCheck(this, CompletionState);\n\n    this.active = active;\n    this.id = id;\n    this.open = open;\n  }\n\n  _createClass(CompletionState, [{\n    key: \"update\",\n    value: function update(tr) {\n      var _this3 = this;\n\n      var state = tr.state,\n          conf = state.facet(completionConfig);\n      var sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n      var active = sources.map(function (source) {\n        var value = _this3.active.find(function (s) {\n          return s.source == source;\n        }) || new ActiveSource(source, _this3.active.some(function (a) {\n          return a.state != 0;\n        }\n        /* Inactive */\n        ) ? 1\n        /* Pending */\n        : 0\n        /* Inactive */\n        );\n        return value.update(tr, conf);\n      });\n      if (active.length == this.active.length && active.every(function (a, i) {\n        return a == _this3.active[i];\n      })) active = this.active;\n      var open = tr.selection || active.some(function (a) {\n        return a.hasResult() && tr.changes.touchesRange(a.from, a.to);\n      }) || !sameResults(active, this.active) ? CompletionDialog.build(active, state, this.id, this.open, conf) : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;\n      if (!open && active.every(function (a) {\n        return a.state != 1;\n      }\n      /* Pending */\n      ) && active.some(function (a) {\n        return a.hasResult();\n      })) active = active.map(function (a) {\n        return a.hasResult() ? new ActiveSource(a.source, 0\n        /* Inactive */\n        ) : a;\n      });\n\n      var _iterator9 = _createForOfIteratorHelper(tr.effects),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var effect = _step9.value;\n          if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n  }, {\n    key: \"tooltip\",\n    get: function get() {\n      return this.open ? this.open.tooltip : null;\n    }\n  }, {\n    key: \"attrs\",\n    get: function get() {\n      return this.open ? this.open.attrs : baseAttrs;\n    }\n  }], [{\n    key: \"start\",\n    value: function start() {\n      return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n  }]);\n\n  return CompletionState;\n}();\n\nfunction sameResults(a, b) {\n  if (a == b) return true;\n\n  for (var iA = 0, iB = 0;;) {\n    while (iA < a.length && !a[iA].hasResult) {\n      iA++;\n    }\n\n    while (iB < b.length && !b[iB].hasResult) {\n      iB++;\n    }\n\n    var endA = iA == a.length,\n        endB = iB == b.length;\n    if (endA || endB) return endA == endB;\n    if (a[iA++].result != b[iB++].result) return false;\n  }\n}\n\nvar baseAttrs = {\n  \"aria-autocomplete\": \"list\"\n};\n\nfunction makeAttrs(id, selected) {\n  var result = {\n    \"aria-autocomplete\": \"list\",\n    \"aria-haspopup\": \"listbox\",\n    \"aria-controls\": id\n  };\n  if (selected > -1) result[\"aria-activedescendant\"] = id + \"-\" + selected;\n  return result;\n}\n\nvar none = [];\n\nfunction getUserEvent(tr) {\n  return tr.isUserEvent(\"input.type\") ? \"input\" : tr.isUserEvent(\"delete.backward\") ? \"delete\" : null;\n}\n\nvar ActiveSource = /*#__PURE__*/function () {\n  function ActiveSource(source, state) {\n    var explicitPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n    _classCallCheck(this, ActiveSource);\n\n    this.source = source;\n    this.state = state;\n    this.explicitPos = explicitPos;\n  }\n\n  _createClass(ActiveSource, [{\n    key: \"hasResult\",\n    value: function hasResult() {\n      return false;\n    }\n  }, {\n    key: \"update\",\n    value: function update(tr, conf) {\n      var event = getUserEvent(tr),\n          value = this;\n      if (event) value = value.handleUserEvent(tr, event, conf);else if (tr.docChanged) value = value.handleChange(tr);else if (tr.selection && value.state != 0\n      /* Inactive */\n      ) value = new ActiveSource(value.source, 0\n      /* Inactive */\n      );\n\n      var _iterator10 = _createForOfIteratorHelper(tr.effects),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var effect = _step10.value;\n          if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1\n          /* Pending */\n          , effect.value ? cur(tr.state) : -1);else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0\n          /* Inactive */\n          );else if (effect.is(setActiveEffect)) {\n            var _iterator11 = _createForOfIteratorHelper(effect.value),\n                _step11;\n\n            try {\n              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                var active = _step11.value;\n                if (active.source == value.source) value = active;\n              }\n            } catch (err) {\n              _iterator11.e(err);\n            } finally {\n              _iterator11.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      return value;\n    }\n  }, {\n    key: \"handleUserEvent\",\n    value: function handleUserEvent(tr, type, conf) {\n      return type == \"delete\" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1\n      /* Pending */\n      );\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(tr) {\n      return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0\n      /* Inactive */\n      ) : this.map(tr.changes);\n    }\n  }, {\n    key: \"map\",\n    value: function map(changes) {\n      return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));\n    }\n  }]);\n\n  return ActiveSource;\n}();\n\nvar ActiveResult = /*#__PURE__*/function (_ActiveSource) {\n  _inherits(ActiveResult, _ActiveSource);\n\n  function ActiveResult(source, explicitPos, result, from, to) {\n    var _this4;\n\n    _classCallCheck(this, ActiveResult);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(ActiveResult).call(this, source, 2\n    /* Result */\n    , explicitPos));\n    _this4.result = result;\n    _this4.from = from;\n    _this4.to = to;\n    return _this4;\n  }\n\n  _createClass(ActiveResult, [{\n    key: \"hasResult\",\n    value: function hasResult() {\n      return true;\n    }\n  }, {\n    key: \"handleUserEvent\",\n    value: function handleUserEvent(tr, type, conf) {\n      var _a;\n\n      var from = tr.changes.mapPos(this.from),\n          to = tr.changes.mapPos(this.to, 1);\n      var pos = cur(tr.state);\n      if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == \"delete\" && cur(tr.startState) == this.from) return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1\n      /* Pending */\n      : 0\n      /* Inactive */\n      );\n      var explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos),\n          updated;\n      if (checkValid(this.result.validFor, tr.state, from, to)) return new ActiveResult(this.source, explicitPos, this.result, from, to);\n      if (this.result.update && (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0)))) return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state));\n      return new ActiveSource(this.source, 1\n      /* Pending */\n      , explicitPos);\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(tr) {\n      return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0\n      /* Inactive */\n      ) : this.map(tr.changes);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));\n    }\n  }]);\n\n  return ActiveResult;\n}(ActiveSource);\n\nfunction checkValid(validFor, state, from, to) {\n  if (!validFor) return false;\n  var text = state.sliceDoc(from, to);\n  return typeof validFor == \"function\" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);\n}\n\nvar startCompletionEffect = /*@__PURE__*/StateEffect.define();\nvar closeCompletionEffect = /*@__PURE__*/StateEffect.define();\nvar setActiveEffect = /*@__PURE__*/StateEffect.define({\n  map: function map(sources, mapping) {\n    return sources.map(function (s) {\n      return s.map(mapping);\n    });\n  }\n});\nvar setSelectedEffect = /*@__PURE__*/StateEffect.define();\nvar completionState = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return CompletionState.start();\n  },\n  update: function update(value, tr) {\n    return value.update(tr);\n  },\n  provide: function provide(f) {\n    return [showTooltip.from(f, function (val) {\n      return val.tooltip;\n    }), EditorView.contentAttributes.from(f, function (state) {\n      return state.attrs;\n    })];\n  }\n});\nvar CompletionInteractMargin = 75;\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/\n\nfunction moveCompletionSelection(forward) {\n  var by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"option\";\n  return function (view) {\n    var cState = view.state.field(completionState, false);\n    if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin) return false;\n    var step = 1,\n        tooltip;\n    if (by == \"page\" && (tooltip = getTooltip(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n    var length = cState.open.options.length;\n    var selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;\n    if (selected < 0) selected = by == \"page\" ? 0 : length - 1;else if (selected >= length) selected = by == \"page\" ? length - 1 : 0;\n    view.dispatch({\n      effects: setSelectedEffect.of(selected)\n    });\n    return true;\n  };\n}\n/**\nAccept the current completion.\n*/\n\n\nvar acceptCompletion = function acceptCompletion(view) {\n  var cState = view.state.field(completionState, false);\n  if (view.state.readOnly || !cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin || cState.open.selected < 0) return false;\n  applyCompletion(view, cState.open.options[cState.open.selected]);\n  return true;\n};\n/**\nExplicitly start autocompletion.\n*/\n\n\nvar startCompletion = function startCompletion(view) {\n  var cState = view.state.field(completionState, false);\n  if (!cState) return false;\n  view.dispatch({\n    effects: startCompletionEffect.of(true)\n  });\n  return true;\n};\n/**\nClose the currently active completion.\n*/\n\n\nvar closeCompletion = function closeCompletion(view) {\n  var cState = view.state.field(completionState, false);\n  if (!cState || !cState.active.some(function (a) {\n    return a.state != 0;\n  }\n  /* Inactive */\n  )) return false;\n  view.dispatch({\n    effects: closeCompletionEffect.of(null)\n  });\n  return true;\n};\n\nvar RunningQuery = function RunningQuery(active, context) {\n  _classCallCheck(this, RunningQuery);\n\n  this.active = active;\n  this.context = context;\n  this.time = Date.now();\n  this.updates = []; // Note that 'undefined' means 'not done yet', whereas 'null' means\n  // 'query returned null'.\n\n  this.done = undefined;\n};\n\nvar DebounceTime = 50,\n    MaxUpdateCount = 50,\n    MinAbortTime = 1000;\nvar completionPlugin = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class(view) {\n    _classCallCheck(this, _class);\n\n    this.view = view;\n    this.debounceUpdate = -1;\n    this.running = [];\n    this.debounceAccept = -1;\n    this.composing = 0\n    /* None */\n    ;\n\n    var _iterator12 = _createForOfIteratorHelper(view.state.field(completionState).active),\n        _step12;\n\n    try {\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        var active = _step12.value;\n        if (active.state == 1\n        /* Pending */\n        ) this.startQuery(active);\n      }\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n  }\n\n  _createClass(_class, [{\n    key: \"update\",\n    value: function update(_update2) {\n      var _this5 = this;\n\n      var cState = _update2.state.field(completionState);\n\n      if (!_update2.selectionSet && !_update2.docChanged && _update2.startState.field(completionState) == cState) return;\n\n      var doesReset = _update2.transactions.some(function (tr) {\n        return (tr.selection || tr.docChanged) && !getUserEvent(tr);\n      });\n\n      for (var i = 0; i < this.running.length; i++) {\n        var query = this.running[i];\n\n        if (doesReset || query.updates.length + _update2.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {\n          var _iterator13 = _createForOfIteratorHelper(query.context.abortListeners),\n              _step13;\n\n          try {\n            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n              var handler = _step13.value;\n\n              try {\n                handler();\n              } catch (e) {\n                logException(this.view.state, e);\n              }\n            }\n          } catch (err) {\n            _iterator13.e(err);\n          } finally {\n            _iterator13.f();\n          }\n\n          query.context.abortListeners = null;\n          this.running.splice(i--, 1);\n        } else {\n          var _query$updates;\n\n          (_query$updates = query.updates).push.apply(_query$updates, _toConsumableArray(_update2.transactions));\n        }\n      }\n\n      if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);\n      this.debounceUpdate = cState.active.some(function (a) {\n        return a.state == 1\n        /* Pending */\n        && !_this5.running.some(function (q) {\n          return q.active.source == a.source;\n        });\n      }) ? setTimeout(function () {\n        return _this5.startUpdate();\n      }, DebounceTime) : -1;\n\n      if (this.composing != 0\n      /* None */\n      ) {\n        var _iterator14 = _createForOfIteratorHelper(_update2.transactions),\n            _step14;\n\n        try {\n          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n            var tr = _step14.value;\n            if (getUserEvent(tr) == \"input\") this.composing = 2\n            /* Changed */\n            ;else if (this.composing == 2\n            /* Changed */\n            && tr.selection) this.composing = 3\n            /* ChangedAndMoved */\n            ;\n          }\n        } catch (err) {\n          _iterator14.e(err);\n        } finally {\n          _iterator14.f();\n        }\n      }\n    }\n  }, {\n    key: \"startUpdate\",\n    value: function startUpdate() {\n      var _this6 = this;\n\n      this.debounceUpdate = -1;\n      var state = this.view.state,\n          cState = state.field(completionState);\n\n      var _iterator15 = _createForOfIteratorHelper(cState.active),\n          _step15;\n\n      try {\n        var _loop = function _loop() {\n          var active = _step15.value;\n          if (active.state == 1\n          /* Pending */\n          && !_this6.running.some(function (r) {\n            return r.active.source == active.source;\n          })) _this6.startQuery(active);\n        };\n\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n    }\n  }, {\n    key: \"startQuery\",\n    value: function startQuery(active) {\n      var _this7 = this;\n\n      var state = this.view.state,\n          pos = cur(state);\n      var context = new CompletionContext(state, pos, active.explicitPos == pos);\n      var pending = new RunningQuery(active, context);\n      this.running.push(pending);\n      Promise.resolve(active.source(context)).then(function (result) {\n        if (!pending.context.aborted) {\n          pending.done = result || null;\n\n          _this7.scheduleAccept();\n        }\n      }, function (err) {\n        _this7.view.dispatch({\n          effects: closeCompletionEffect.of(null)\n        });\n\n        logException(_this7.view.state, err);\n      });\n    }\n  }, {\n    key: \"scheduleAccept\",\n    value: function scheduleAccept() {\n      var _this8 = this;\n\n      if (this.running.every(function (q) {\n        return q.done !== undefined;\n      })) this.accept();else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(function () {\n        return _this8.accept();\n      }, DebounceTime);\n    } // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n\n  }, {\n    key: \"accept\",\n    value: function accept() {\n      var _this9 = this;\n\n      var _a;\n\n      if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);\n      this.debounceAccept = -1;\n      var updated = [];\n      var conf = this.view.state.facet(completionConfig);\n\n      var _loop2 = function _loop2(_i2) {\n        var query = _this9.running[_i2];\n\n        if (query.done === undefined) {\n          i = _i2;\n          return \"continue\";\n        }\n\n        _this9.running.splice(_i2--, 1);\n\n        if (query.done) {\n          var active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : _this9.view.state)); // Replay the transactions that happened since the start of\n          // the request and see if that preserves the result\n\n          var _iterator16 = _createForOfIteratorHelper(query.updates),\n              _step16;\n\n          try {\n            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n              var tr = _step16.value;\n              active = active.update(tr, conf);\n            }\n          } catch (err) {\n            _iterator16.e(err);\n          } finally {\n            _iterator16.f();\n          }\n\n          if (active.hasResult()) {\n            updated.push(active);\n            i = _i2;\n            return \"continue\";\n          }\n        }\n\n        var current = _this9.view.state.field(completionState).active.find(function (a) {\n          return a.source == query.active.source;\n        });\n\n        if (current && current.state == 1\n        /* Pending */\n        ) {\n          if (query.done == null) {\n            // Explicitly failed. Should clear the pending status if it\n            // hasn't been re-set in the meantime.\n            var _active = new ActiveSource(query.active.source, 0\n            /* Inactive */\n            );\n\n            var _iterator17 = _createForOfIteratorHelper(query.updates),\n                _step17;\n\n            try {\n              for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                var _tr = _step17.value;\n                _active = _active.update(_tr, conf);\n              }\n            } catch (err) {\n              _iterator17.e(err);\n            } finally {\n              _iterator17.f();\n            }\n\n            if (_active.state != 1\n            /* Pending */\n            ) updated.push(_active);\n          } else {\n            // Cleared by subsequent transactions. Restart.\n            _this9.startQuery(current);\n          }\n        }\n\n        i = _i2;\n      };\n\n      for (var i = 0; i < this.running.length; i++) {\n        var _ret = _loop2(i);\n\n        if (_ret === \"continue\") continue;\n      }\n\n      if (updated.length) this.view.dispatch({\n        effects: setActiveEffect.of(updated)\n      });\n    }\n  }]);\n\n  return _class;\n}(), {\n  eventHandlers: {\n    blur: function blur() {\n      var state = this.view.state.field(completionState, false);\n      if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) this.view.dispatch({\n        effects: closeCompletionEffect.of(null)\n      });\n    },\n    compositionstart: function compositionstart() {\n      this.composing = 1\n      /* Started */\n      ;\n    },\n    compositionend: function compositionend() {\n      var _this10 = this;\n\n      if (this.composing == 3\n      /* ChangedAndMoved */\n      ) {\n        // Safari fires compositionend events synchronously, possibly\n        // from inside an update, so dispatch asynchronously to avoid reentrancy\n        setTimeout(function () {\n          return _this10.view.dispatch({\n            effects: startCompletionEffect.of(false)\n          });\n        }, 20);\n      }\n\n      this.composing = 0\n      /* None */\n      ;\n    }\n  }\n});\nvar baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-tooltip.cm-tooltip-autocomplete\": {\n    \"& > ul\": {\n      fontFamily: \"monospace\",\n      whiteSpace: \"nowrap\",\n      overflow: \"hidden auto\",\n      maxWidth_fallback: \"700px\",\n      maxWidth: \"min(700px, 95vw)\",\n      minWidth: \"250px\",\n      maxHeight: \"10em\",\n      listStyle: \"none\",\n      margin: 0,\n      padding: 0,\n      \"& > li\": {\n        overflowX: \"hidden\",\n        textOverflow: \"ellipsis\",\n        cursor: \"pointer\",\n        padding: \"1px 3px\",\n        lineHeight: 1.2\n      }\n    }\n  },\n  \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n    background: \"#17c\",\n    color: \"white\"\n  },\n  \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n    background: \"#347\",\n    color: \"white\"\n  },\n  \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n    content: '\"···\"',\n    opacity: 0.5,\n    display: \"block\",\n    textAlign: \"center\"\n  },\n  \".cm-tooltip.cm-completionInfo\": {\n    position: \"absolute\",\n    padding: \"3px 9px\",\n    width: \"max-content\",\n    maxWidth: \"300px\"\n  },\n  \".cm-completionInfo.cm-completionInfo-left\": {\n    right: \"100%\"\n  },\n  \".cm-completionInfo.cm-completionInfo-right\": {\n    left: \"100%\"\n  },\n  \"&light .cm-snippetField\": {\n    backgroundColor: \"#00000022\"\n  },\n  \"&dark .cm-snippetField\": {\n    backgroundColor: \"#ffffff22\"\n  },\n  \".cm-snippetFieldPosition\": {\n    verticalAlign: \"text-top\",\n    width: 0,\n    height: \"1.15em\",\n    margin: \"0 -0.7px -.7em\",\n    borderLeft: \"1.4px dotted #888\"\n  },\n  \".cm-completionMatchedText\": {\n    textDecoration: \"underline\"\n  },\n  \".cm-completionDetail\": {\n    marginLeft: \"0.5em\",\n    fontStyle: \"italic\"\n  },\n  \".cm-completionIcon\": {\n    fontSize: \"90%\",\n    width: \".8em\",\n    display: \"inline-block\",\n    textAlign: \"center\",\n    paddingRight: \".6em\",\n    opacity: \"0.6\"\n  },\n  \".cm-completionIcon-function, .cm-completionIcon-method\": {\n    \"&:after\": {\n      content: \"'ƒ'\"\n    }\n  },\n  \".cm-completionIcon-class\": {\n    \"&:after\": {\n      content: \"'○'\"\n    }\n  },\n  \".cm-completionIcon-interface\": {\n    \"&:after\": {\n      content: \"'◌'\"\n    }\n  },\n  \".cm-completionIcon-variable\": {\n    \"&:after\": {\n      content: \"'𝑥'\"\n    }\n  },\n  \".cm-completionIcon-constant\": {\n    \"&:after\": {\n      content: \"'𝐶'\"\n    }\n  },\n  \".cm-completionIcon-type\": {\n    \"&:after\": {\n      content: \"'𝑡'\"\n    }\n  },\n  \".cm-completionIcon-enum\": {\n    \"&:after\": {\n      content: \"'∪'\"\n    }\n  },\n  \".cm-completionIcon-property\": {\n    \"&:after\": {\n      content: \"'□'\"\n    }\n  },\n  \".cm-completionIcon-keyword\": {\n    \"&:after\": {\n      content: \"'\\uD83D\\uDD11\\uFE0E'\"\n    } // Disable emoji rendering\n\n  },\n  \".cm-completionIcon-namespace\": {\n    \"&:after\": {\n      content: \"'▢'\"\n    }\n  },\n  \".cm-completionIcon-text\": {\n    \"&:after\": {\n      content: \"'abc'\",\n      fontSize: \"50%\",\n      verticalAlign: \"middle\"\n    }\n  }\n});\n\nvar FieldPos = function FieldPos(field, line, from, to) {\n  _classCallCheck(this, FieldPos);\n\n  this.field = field;\n  this.line = line;\n  this.from = from;\n  this.to = to;\n};\n\nvar FieldRange = /*#__PURE__*/function () {\n  function FieldRange(field, from, to) {\n    _classCallCheck(this, FieldRange);\n\n    this.field = field;\n    this.from = from;\n    this.to = to;\n  }\n\n  _createClass(FieldRange, [{\n    key: \"map\",\n    value: function map(changes) {\n      var from = changes.mapPos(this.from, -1, MapMode.TrackDel);\n      var to = changes.mapPos(this.to, 1, MapMode.TrackDel);\n      return from == null || to == null ? null : new FieldRange(this.field, from, to);\n    }\n  }]);\n\n  return FieldRange;\n}();\n\nvar Snippet = /*#__PURE__*/function () {\n  function Snippet(lines, fieldPositions) {\n    _classCallCheck(this, Snippet);\n\n    this.lines = lines;\n    this.fieldPositions = fieldPositions;\n  }\n\n  _createClass(Snippet, [{\n    key: \"instantiate\",\n    value: function instantiate(state, pos) {\n      var text = [],\n          lineStart = [pos];\n      var lineObj = state.doc.lineAt(pos),\n          baseIndent = /^\\s*/.exec(lineObj.text)[0];\n\n      var _iterator18 = _createForOfIteratorHelper(this.lines),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var line = _step18.value;\n\n          if (text.length) {\n            var indent = baseIndent,\n                tabs = /^\\t*/.exec(line)[0].length;\n\n            for (var _i3 = 0; _i3 < tabs; _i3++) {\n              indent += state.facet(indentUnit);\n            }\n\n            lineStart.push(pos + indent.length - tabs);\n            line = indent + line.slice(tabs);\n          }\n\n          text.push(line);\n          pos += line.length + 1;\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n\n      var ranges = this.fieldPositions.map(function (pos) {\n        return new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to);\n      });\n      return {\n        text: text,\n        ranges: ranges\n      };\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(template) {\n      var fields = [];\n      var lines = [],\n          positions = [],\n          m;\n\n      var _iterator19 = _createForOfIteratorHelper(template.split(/\\r\\n?|\\n/)),\n          _step19;\n\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var line = _step19.value;\n\n          while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)) {\n            var seq = m[1] ? +m[1] : null,\n                name = m[2] || m[3] || \"\",\n                found = -1;\n\n            for (var _i4 = 0; _i4 < fields.length; _i4++) {\n              if (seq != null ? fields[_i4].seq == seq : name ? fields[_i4].name == name : false) found = _i4;\n            }\n\n            if (found < 0) {\n              var _i5 = 0;\n\n              while (_i5 < fields.length && (seq == null || fields[_i5].seq != null && fields[_i5].seq < seq)) {\n                _i5++;\n              }\n\n              fields.splice(_i5, 0, {\n                seq: seq,\n                name: name\n              });\n              found = _i5;\n\n              var _iterator20 = _createForOfIteratorHelper(positions),\n                  _step20;\n\n              try {\n                for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                  var pos = _step20.value;\n                  if (pos.field >= found) pos.field++;\n                }\n              } catch (err) {\n                _iterator20.e(err);\n              } finally {\n                _iterator20.f();\n              }\n            }\n\n            positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n            line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n          }\n\n          for (var esc; esc = /([$#])\\\\{/.exec(line);) {\n            line = line.slice(0, esc.index) + esc[1] + \"{\" + line.slice(esc.index + esc[0].length);\n\n            var _iterator21 = _createForOfIteratorHelper(positions),\n                _step21;\n\n            try {\n              for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                var _pos = _step21.value;\n\n                if (_pos.line == lines.length && _pos.from > esc.index) {\n                  _pos.from--;\n                  _pos.to--;\n                }\n              }\n            } catch (err) {\n              _iterator21.e(err);\n            } finally {\n              _iterator21.f();\n            }\n          }\n\n          lines.push(line);\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n\n      return new Snippet(lines, positions);\n    }\n  }]);\n\n  return Snippet;\n}();\n\nvar fieldMarker = /*@__PURE__*/Decoration.widget({\n  widget: /*@__PURE__*/new ( /*#__PURE__*/function (_WidgetType) {\n    _inherits(_class2, _WidgetType);\n\n    function _class2() {\n      _classCallCheck(this, _class2);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(_class2).apply(this, arguments));\n    }\n\n    _createClass(_class2, [{\n      key: \"toDOM\",\n      value: function toDOM() {\n        var span = document.createElement(\"span\");\n        span.className = \"cm-snippetFieldPosition\";\n        return span;\n      }\n    }, {\n      key: \"ignoreEvent\",\n      value: function ignoreEvent() {\n        return false;\n      }\n    }]);\n\n    return _class2;\n  }(WidgetType))()\n});\nvar fieldRange = /*@__PURE__*/Decoration.mark({\n  class: \"cm-snippetField\"\n});\n\nvar ActiveSnippet = /*#__PURE__*/function () {\n  function ActiveSnippet(ranges, active) {\n    _classCallCheck(this, ActiveSnippet);\n\n    this.ranges = ranges;\n    this.active = active;\n    this.deco = Decoration.set(ranges.map(function (r) {\n      return (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to);\n    }));\n  }\n\n  _createClass(ActiveSnippet, [{\n    key: \"map\",\n    value: function map(changes) {\n      var ranges = [];\n\n      var _iterator22 = _createForOfIteratorHelper(this.ranges),\n          _step22;\n\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var r = _step22.value;\n          var mapped = r.map(changes);\n          if (!mapped) return null;\n          ranges.push(mapped);\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n\n      return new ActiveSnippet(ranges, this.active);\n    }\n  }, {\n    key: \"selectionInsideField\",\n    value: function selectionInsideField(sel) {\n      var _this11 = this;\n\n      return sel.ranges.every(function (range) {\n        return _this11.ranges.some(function (r) {\n          return r.field == _this11.active && r.from <= range.from && r.to >= range.to;\n        });\n      });\n    }\n  }]);\n\n  return ActiveSnippet;\n}();\n\nvar setActive = /*@__PURE__*/StateEffect.define({\n  map: function map(value, changes) {\n    return value && value.map(changes);\n  }\n});\nvar moveToField = /*@__PURE__*/StateEffect.define();\nvar snippetState = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return null;\n  },\n  update: function update(value, tr) {\n    var _iterator23 = _createForOfIteratorHelper(tr.effects),\n        _step23;\n\n    try {\n      for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n        var effect = _step23.value;\n        if (effect.is(setActive)) return effect.value;\n        if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);\n      }\n    } catch (err) {\n      _iterator23.e(err);\n    } finally {\n      _iterator23.f();\n    }\n\n    if (value && tr.docChanged) value = value.map(tr.changes);\n    if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;\n    return value;\n  },\n  provide: function provide(f) {\n    return EditorView.decorations.from(f, function (val) {\n      return val ? val.deco : Decoration.none;\n    });\n  }\n});\n\nfunction fieldSelection(ranges, field) {\n  return EditorSelection.create(ranges.filter(function (r) {\n    return r.field == field;\n  }).map(function (r) {\n    return EditorSelection.range(r.from, r.to);\n  }));\n}\n/**\nConvert a snippet template to a function that can\n[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written\nusing syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n\nTo include a literal `${` or `#{` in your template, put a\nbackslash after the dollar or hash and before the brace (`$\\\\{`).\nThis will be removed and the sequence will not be interpreted as a\nplaceholder.\n*/\n\n\nfunction snippet(template) {\n  var snippet = Snippet.parse(template);\n  return function (editor, _completion, from, to) {\n    var _snippet$instantiate = snippet.instantiate(editor.state, from),\n        text = _snippet$instantiate.text,\n        ranges = _snippet$instantiate.ranges;\n\n    var spec = {\n      changes: {\n        from: from,\n        to: to,\n        insert: Text.of(text)\n      },\n      scrollIntoView: true\n    };\n    if (ranges.length) spec.selection = fieldSelection(ranges, 0);\n\n    if (ranges.length > 1) {\n      var active = new ActiveSnippet(ranges, 0);\n      var effects = spec.effects = [setActive.of(active)];\n      if (editor.state.field(snippetState, false) === undefined) effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));\n    }\n\n    editor.dispatch(editor.state.update(spec));\n  };\n}\n\nfunction moveField(dir) {\n  return function (_ref3) {\n    var state = _ref3.state,\n        dispatch = _ref3.dispatch;\n    var active = state.field(snippetState, false);\n    if (!active || dir < 0 && active.active == 0) return false;\n    var next = active.active + dir,\n        last = dir > 0 && !active.ranges.some(function (r) {\n      return r.field == next + dir;\n    });\n    dispatch(state.update({\n      selection: fieldSelection(active.ranges, next),\n      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))\n    }));\n    return true;\n  };\n}\n/**\nA command that clears the active snippet, if any.\n*/\n\n\nvar clearSnippet = function clearSnippet(_ref4) {\n  var state = _ref4.state,\n      dispatch = _ref4.dispatch;\n  var active = state.field(snippetState, false);\n  if (!active) return false;\n  dispatch(state.update({\n    effects: setActive.of(null)\n  }));\n  return true;\n};\n/**\nMove to the next snippet field, if available.\n*/\n\n\nvar nextSnippetField = /*@__PURE__*/moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/\n\nvar prevSnippetField = /*@__PURE__*/moveField(-1);\nvar defaultSnippetKeymap = [{\n  key: \"Tab\",\n  run: nextSnippetField,\n  shift: prevSnippetField\n}, {\n  key: \"Escape\",\n  run: clearSnippet\n}];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/\n\nvar snippetKeymap = /*@__PURE__*/Facet.define({\n  combine: function combine(maps) {\n    return maps.length ? maps[0] : defaultSnippetKeymap;\n  }\n});\nvar addSnippetKeymap = /*@__PURE__*/Prec.highest( /*@__PURE__*/keymap.compute([snippetKeymap], function (state) {\n  return state.facet(snippetKeymap);\n}));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/\n\nfunction snippetCompletion(template, completion) {\n  return Object.assign(Object.assign({}, completion), {\n    apply: snippet(template)\n  });\n}\n\nvar snippetPointerHandler = /*@__PURE__*/EditorView.domEventHandlers({\n  mousedown: function mousedown(event, view) {\n    var active = view.state.field(snippetState, false),\n        pos;\n    if (!active || (pos = view.posAtCoords({\n      x: event.clientX,\n      y: event.clientY\n    })) == null) return false;\n    var match = active.ranges.find(function (r) {\n      return r.from <= pos && r.to >= pos;\n    });\n    if (!match || match.field == active.active) return false;\n    view.dispatch({\n      selection: fieldSelection(active.ranges, match.field),\n      effects: setActive.of(active.ranges.some(function (r) {\n        return r.field > match.field;\n      }) ? new ActiveSnippet(active.ranges, match.field) : null)\n    });\n    return true;\n  }\n});\n\nfunction wordRE(wordChars) {\n  var escaped = wordChars.replace(/[\\\\[.+*?(){|^$]/g, \"\\\\$&\");\n\n  try {\n    return new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_\".concat(escaped, \"]+\"), \"ug\");\n  } catch (_a) {\n    return new RegExp(\"[w\".concat(escaped, \"]\"), \"g\");\n  }\n}\n\nfunction mapRE(re, f) {\n  return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\n\nvar wordCaches = /*@__PURE__*/Object.create(null);\n\nfunction wordCache(wordChars) {\n  return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap());\n}\n\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n  for (var lines = doc.iterLines(), pos = 0; !lines.next().done;) {\n    var value = lines.value,\n        m = void 0;\n    wordRE.lastIndex = 0;\n\n    while (m = wordRE.exec(value)) {\n      if (!seen[m[0]] && pos + m.index != ignoreAt) {\n        result.push({\n          type: \"text\",\n          label: m[0]\n        });\n        seen[m[0]] = true;\n        if (result.length >= 2000\n        /* MaxList */\n        ) return;\n      }\n    }\n\n    pos += value.length + 1;\n  }\n}\n\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n  var big = doc.length >= 1000\n  /* MinCacheLen */\n  ;\n  var cached = big && cache.get(doc);\n  if (cached) return cached;\n  var result = [],\n      seen = Object.create(null);\n\n  if (doc.children) {\n    var pos = 0;\n\n    var _iterator24 = _createForOfIteratorHelper(doc.children),\n        _step24;\n\n    try {\n      for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n        var ch = _step24.value;\n\n        if (ch.length >= 1000\n        /* MinCacheLen */\n        ) {\n          var _iterator25 = _createForOfIteratorHelper(collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)),\n              _step25;\n\n          try {\n            for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n              var c = _step25.value;\n\n              if (!seen[c.label]) {\n                seen[c.label] = true;\n                result.push(c);\n              }\n            }\n          } catch (err) {\n            _iterator25.e(err);\n          } finally {\n            _iterator25.f();\n          }\n        } else {\n          storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n        }\n\n        pos += ch.length + 1;\n      }\n    } catch (err) {\n      _iterator24.e(err);\n    } finally {\n      _iterator24.f();\n    }\n  } else {\n    storeWords(doc, wordRE, result, seen, ignoreAt);\n  }\n\n  if (big && result.length < 2000\n  /* MaxList */\n  ) cache.set(doc, result);\n  return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/\n\n\nvar completeAnyWord = function completeAnyWord(context) {\n  var wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n  var re = wordRE(wordChars);\n  var token = context.matchBefore(mapRE(re, function (s) {\n    return s + \"$\";\n  }));\n  if (!token && !context.explicit) return null;\n  var from = token ? token.from : context.pos;\n  var options = collectWords(context.state.doc, wordCache(wordChars), re, 50000\n  /* Range */\n  , from);\n  return {\n    from: from,\n    options: options,\n    validFor: mapRE(re, function (s) {\n      return \"^\" + s;\n    })\n  };\n};\n\nvar defaults = {\n  brackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\n  before: \")]}:;>\"\n};\nvar closeBracketEffect = /*@__PURE__*/StateEffect.define({\n  map: function map(value, mapping) {\n    var mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);\n    return mapped == null ? undefined : mapped;\n  }\n});\nvar skipBracketEffect = /*@__PURE__*/StateEffect.define({\n  map: function map(value, mapping) {\n    return mapping.mapPos(value);\n  }\n});\nvar closedBracket = /*@__PURE__*/new ( /*#__PURE__*/function (_RangeValue) {\n  _inherits(_class3, _RangeValue);\n\n  function _class3() {\n    _classCallCheck(this, _class3);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(_class3).apply(this, arguments));\n  }\n\n  return _class3;\n}(RangeValue))();\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nvar bracketState = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return RangeSet.empty;\n  },\n  update: function update(value, tr) {\n    if (tr.selection) {\n      var lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;\n      var prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;\n      if (lineStart != tr.changes.mapPos(prevLineStart, -1)) value = RangeSet.empty;\n    }\n\n    value = value.map(tr.changes);\n\n    var _iterator26 = _createForOfIteratorHelper(tr.effects),\n        _step26;\n\n    try {\n      var _loop3 = function _loop3() {\n        var effect = _step26.value;\n        if (effect.is(closeBracketEffect)) value = value.update({\n          add: [closedBracket.range(effect.value, effect.value + 1)]\n        });else if (effect.is(skipBracketEffect)) value = value.update({\n          filter: function filter(from) {\n            return from != effect.value;\n          }\n        });\n      };\n\n      for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n        _loop3();\n      }\n    } catch (err) {\n      _iterator26.e(err);\n    } finally {\n      _iterator26.f();\n    }\n\n    return value;\n  }\n});\n/**\nExtension to enable bracket-closing behavior. When a closeable\nbracket is typed, its closing bracket is immediately inserted\nafter the cursor. When closing a bracket directly in front of a\nclosing bracket inserted by the extension, the cursor moves over\nthat bracket.\n*/\n\nfunction closeBrackets() {\n  return [inputHandler, bracketState];\n}\n\nvar definedClosing = \"()[]{}<>\";\n\nfunction closing(ch) {\n  for (var _i6 = 0; _i6 < definedClosing.length; _i6 += 2) {\n    if (definedClosing.charCodeAt(_i6) == ch) return definedClosing.charAt(_i6 + 1);\n  }\n\n  return fromCodePoint(ch < 128 ? ch : ch + 1);\n}\n\nfunction config(state, pos) {\n  return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\n\nvar android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\nvar inputHandler = /*@__PURE__*/EditorView.inputHandler.of(function (view, from, to, insert) {\n  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly) return false;\n  var sel = view.state.selection.main;\n  if (insert.length > 2 || insert.length == 2 && codePointSize(codePointAt(insert, 0)) == 1 || from != sel.from || to != sel.to) return false;\n  var tr = insertBracket(view.state, insert);\n  if (!tr) return false;\n  view.dispatch(tr);\n  return true;\n});\n/**\nCommand that implements deleting a pair of matching brackets when\nthe cursor is between them.\n*/\n\nvar deleteBracketPair = function deleteBracketPair(_ref5) {\n  var state = _ref5.state,\n      dispatch = _ref5.dispatch;\n  if (state.readOnly) return false;\n  var conf = config(state, state.selection.main.head);\n  var tokens = conf.brackets || defaults.brackets;\n  var dont = null,\n      changes = state.changeByRange(function (range) {\n    if (range.empty) {\n      var before = prevChar(state.doc, range.head);\n\n      var _iterator27 = _createForOfIteratorHelper(tokens),\n          _step27;\n\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var token = _step27.value;\n          if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0))) return {\n            changes: {\n              from: range.head - token.length,\n              to: range.head + token.length\n            },\n            range: EditorSelection.cursor(range.head - token.length),\n            userEvent: \"delete.backward\"\n          };\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n    }\n\n    return {\n      range: dont = range\n    };\n  });\n  if (!dont) dispatch(state.update(changes, {\n    scrollIntoView: true\n  }));\n  return !dont;\n};\n/**\nClose-brackets related key bindings. Binds Backspace to\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).\n*/\n\n\nvar closeBracketsKeymap = [{\n  key: \"Backspace\",\n  run: deleteBracketPair\n}];\n/**\nImplements the extension's behavior on text insertion. If the\ngiven string counts as a bracket in the language around the\nselection, and replacing the selection with it requires custom\nbehavior (inserting a closing version or skipping past a\npreviously-closed bracket), this function returns a transaction\nrepresenting that custom behavior. (You only need this if you want\nto programmatically insert brackets—the\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will\ntake care of running this for user input.)\n*/\n\nfunction insertBracket(state, bracket) {\n  var conf = config(state, state.selection.main.head);\n  var tokens = conf.brackets || defaults.brackets;\n\n  var _iterator28 = _createForOfIteratorHelper(tokens),\n      _step28;\n\n  try {\n    for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n      var tok = _step28.value;\n      var closed = closing(codePointAt(tok, 0));\n      if (bracket == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1) : handleOpen(state, tok, closed, conf.before || defaults.before);\n      if (bracket == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);\n    }\n  } catch (err) {\n    _iterator28.e(err);\n  } finally {\n    _iterator28.f();\n  }\n\n  return null;\n}\n\nfunction closedBracketAt(state, pos) {\n  var found = false;\n  state.field(bracketState).between(0, state.doc.length, function (from) {\n    if (from == pos) found = true;\n  });\n  return found;\n}\n\nfunction nextChar(doc, pos) {\n  var next = doc.sliceString(pos, pos + 2);\n  return next.slice(0, codePointSize(codePointAt(next, 0)));\n}\n\nfunction prevChar(doc, pos) {\n  var prev = doc.sliceString(pos - 2, pos);\n  return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\n\nfunction handleOpen(state, open, close, closeBefore) {\n  var dont = null,\n      changes = state.changeByRange(function (range) {\n    if (!range.empty) return {\n      changes: [{\n        insert: open,\n        from: range.from\n      }, {\n        insert: close,\n        from: range.to\n      }],\n      effects: closeBracketEffect.of(range.to + open.length),\n      range: EditorSelection.range(range.anchor + open.length, range.head + open.length)\n    };\n    var next = nextChar(state.doc, range.head);\n    if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1) return {\n      changes: {\n        insert: open + close,\n        from: range.head\n      },\n      effects: closeBracketEffect.of(range.head + open.length),\n      range: EditorSelection.cursor(range.head + open.length)\n    };\n    return {\n      range: dont = range\n    };\n  });\n  return dont ? null : state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input.type\"\n  });\n}\n\nfunction handleClose(state, _open, close) {\n  var dont = null,\n      moved = state.selection.ranges.map(function (range) {\n    if (range.empty && nextChar(state.doc, range.head) == close) return EditorSelection.cursor(range.head + close.length);\n    return dont = range;\n  });\n  return dont ? null : state.update({\n    selection: EditorSelection.create(moved, state.selection.mainIndex),\n    scrollIntoView: true,\n    effects: state.selection.ranges.map(function (_ref6) {\n      var from = _ref6.from;\n      return skipBracketEffect.of(from);\n    })\n  });\n} // Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\n\n\nfunction handleSame(state, token, allowTriple) {\n  var dont = null,\n      changes = state.changeByRange(function (range) {\n    if (!range.empty) return {\n      changes: [{\n        insert: token,\n        from: range.from\n      }, {\n        insert: token,\n        from: range.to\n      }],\n      effects: closeBracketEffect.of(range.to + token.length),\n      range: EditorSelection.range(range.anchor + token.length, range.head + token.length)\n    };\n    var pos = range.head,\n        next = nextChar(state.doc, pos);\n\n    if (next == token) {\n      if (nodeStart(state, pos)) {\n        return {\n          changes: {\n            insert: token + token,\n            from: pos\n          },\n          effects: closeBracketEffect.of(pos + token.length),\n          range: EditorSelection.cursor(pos + token.length)\n        };\n      } else if (closedBracketAt(state, pos)) {\n        var isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n        return {\n          range: EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),\n          effects: skipBracketEffect.of(pos)\n        };\n      }\n    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && nodeStart(state, pos - 2 * token.length)) {\n      return {\n        changes: {\n          insert: token + token + token + token,\n          from: pos\n        },\n        effects: closeBracketEffect.of(pos + token.length),\n        range: EditorSelection.cursor(pos + token.length)\n      };\n    } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {\n      var prev = state.sliceDoc(pos - 1, pos);\n      if (prev != token && state.charCategorizer(pos)(prev) != CharCategory.Word && !probablyInString(state, pos, token)) return {\n        changes: {\n          insert: token + token,\n          from: pos\n        },\n        effects: closeBracketEffect.of(pos + token.length),\n        range: EditorSelection.cursor(pos + token.length)\n      };\n    }\n\n    return {\n      range: dont = range\n    };\n  });\n  return dont ? null : state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input.type\"\n  });\n}\n\nfunction nodeStart(state, pos) {\n  var tree = syntaxTree(state).resolveInner(pos + 1);\n  return tree.parent && tree.from == pos;\n}\n\nfunction probablyInString(state, pos, quoteToken) {\n  var node = syntaxTree(state).resolveInner(pos, -1);\n\n  for (var _i7 = 0; _i7 < 5; _i7++) {\n    if (state.sliceDoc(node.from, node.from + quoteToken.length) == quoteToken) {\n      var first = node.firstChild;\n\n      while (first && first.from == node.from && first.to - first.from > quoteToken.length) {\n        if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken) return false;\n        first = first.firstChild;\n      }\n\n      return true;\n    }\n\n    var parent = node.to == pos && node.parent;\n    if (!parent) break;\n    node = parent;\n  }\n\n  return false;\n}\n/**\nReturns an extension that enables autocompletion.\n*/\n\n\nfunction autocompletion() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [completionState, completionConfig.of(config), completionPlugin, completionKeymapExt, baseTheme];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/\n\n\nvar completionKeymap = [{\n  key: \"Ctrl-Space\",\n  run: startCompletion\n}, {\n  key: \"Escape\",\n  run: closeCompletion\n}, {\n  key: \"ArrowDown\",\n  run: /*@__PURE__*/moveCompletionSelection(true)\n}, {\n  key: \"ArrowUp\",\n  run: /*@__PURE__*/moveCompletionSelection(false)\n}, {\n  key: \"PageDown\",\n  run: /*@__PURE__*/moveCompletionSelection(true, \"page\")\n}, {\n  key: \"PageUp\",\n  run: /*@__PURE__*/moveCompletionSelection(false, \"page\")\n}, {\n  key: \"Enter\",\n  run: acceptCompletion\n}];\nvar completionKeymapExt = /*@__PURE__*/Prec.highest( /*@__PURE__*/keymap.computeN([completionConfig], function (state) {\n  return state.facet(completionConfig).defaultKeymap ? [completionKeymap] : [];\n}));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/\n\nfunction completionStatus(state) {\n  var cState = state.field(completionState, false);\n  return cState && cState.active.some(function (a) {\n    return a.state == 1;\n  }\n  /* Pending */\n  ) ? \"pending\" : cState && cState.active.some(function (a) {\n    return a.state != 0;\n  }\n  /* Inactive */\n  ) ? \"active\" : null;\n}\n\nvar completionArrayCache = /*@__PURE__*/new WeakMap();\n/**\nReturns the available completions as an array.\n*/\n\nfunction currentCompletions(state) {\n  var _a;\n\n  var open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  if (!open) return [];\n  var completions = completionArrayCache.get(open.options);\n  if (!completions) completionArrayCache.set(open.options, completions = open.options.map(function (o) {\n    return o.completion;\n  }));\n  return completions;\n}\n/**\nReturn the currently selected completion, if any.\n*/\n\n\nfunction selectedCompletion(state) {\n  var _a;\n\n  var open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  return open && open.selected >= 0 ? open.options[open.selected].completion : null;\n}\n/**\nReturns the currently selected position in the active completion\nlist, or null if no completions are active.\n*/\n\n\nfunction selectedCompletionIndex(state) {\n  var _a;\n\n  var open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  return open && open.selected >= 0 ? open.selected : null;\n}\n/**\nCreate an effect that can be attached to a transaction to change\nthe currently selected completion.\n*/\n\n\nfunction setSelectedCompletion(index) {\n  return setSelectedEffect.of(index);\n}\n\nexport { CompletionContext, acceptCompletion, autocompletion, clearSnippet, closeBrackets, closeBracketsKeymap, closeCompletion, completeAnyWord, completeFromList, completionKeymap, completionStatus, currentCompletions, deleteBracketPair, ifIn, ifNotIn, insertBracket, insertCompletionText, moveCompletionSelection, nextSnippetField, pickedCompletion, prevSnippetField, selectedCompletion, selectedCompletionIndex, setSelectedCompletion, snippet, snippetCompletion, snippetKeymap, startCompletion };","map":null,"metadata":{},"sourceType":"module"}