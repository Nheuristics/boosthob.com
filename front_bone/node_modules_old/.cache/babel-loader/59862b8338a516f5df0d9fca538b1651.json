{"ast":null,"code":"import _classCallCheck from \"/home/ayaz/Projects/boosthub.com/front_bone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/ayaz/Projects/boosthub.com/front_bone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { NodeProp } from '@lezer/common';\nvar nextTagID = 0; /// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlighter](#highlight.Highlighter).\n///\n/// Because syntax tree node types and highlight styles have to be\n/// able to talk the same language, CodeMirror uses a mostly _closed_\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\n/// traditional open string-based systems, which make it hard for\n/// highlighting themes to cover all the tokens produced by the\n/// various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by regular highlighters (though you can derive them\n/// from standard tags to allow highlighters to fall back to those).\n\nvar Tag = /*#__PURE__*/function () {\n  /// @internal\n  function Tag( /// The set of this tag and all its parent tags, starting with\n  /// this one itself and sorted in order of decreasing specificity.\n  set, /// The base unmodified tag that this one is based on, if it's\n  /// modified @internal\n  base, /// The modifiers applied to this.base @internal\n  modified) {\n    _classCallCheck(this, Tag);\n\n    this.set = set;\n    this.base = base;\n    this.modified = modified; /// @internal\n\n    this.id = nextTagID++;\n  } /// Define a new tag. If `parent` is given, the tag is treated as a\n  /// sub-tag of that parent, and\n  /// [highlighters](#highlight.tagHighlighter) that don't mention\n  /// this tag will try to fall back to the parent tag (or grandparent\n  /// tag, etc).\n\n\n  _createClass(Tag, null, [{\n    key: \"define\",\n    value: function define(parent) {\n      if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n      var tag = new Tag([], null, []);\n      tag.set.push(tag);\n\n      if (parent) {\n        var _iterator = _createForOfIteratorHelper(parent.set),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _t = _step.value;\n            tag.set.push(_t);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return tag;\n    } /// Define a tag _modifier_, which is a function that, given a tag,\n    /// will return a tag that is a subtag of the original. Applying the\n    /// same modifier to a twice tag will return the same value (`m1(t1)\n    /// == m1(t1)`) and applying multiple modifiers will, regardless or\n    /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    ///\n    /// When multiple modifiers are applied to a given base tag, each\n    /// smaller set of modifiers is registered as a parent, so that for\n    /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    /// `m1(m3(t1)`, and so on.\n\n  }, {\n    key: \"defineModifier\",\n    value: function defineModifier() {\n      var mod = new Modifier();\n      return function (tag) {\n        if (tag.modified.indexOf(mod) > -1) return tag;\n        return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort(function (a, b) {\n          return a.id - b.id;\n        }));\n      };\n    }\n  }]);\n\n  return Tag;\n}();\n\nvar nextModifierID = 0;\n\nvar Modifier = /*#__PURE__*/function () {\n  function Modifier() {\n    _classCallCheck(this, Modifier);\n\n    this.instances = [];\n    this.id = nextModifierID++;\n  }\n\n  _createClass(Modifier, null, [{\n    key: \"get\",\n    value: function get(base, mods) {\n      if (!mods.length) return base;\n      var exists = mods[0].instances.find(function (t) {\n        return t.base == base && sameArray(mods, t.modified);\n      });\n      if (exists) return exists;\n      var set = [],\n          tag = new Tag(set, base, mods);\n\n      var _iterator2 = _createForOfIteratorHelper(mods),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var m = _step2.value;\n          m.instances.push(tag);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var configs = permute(mods);\n\n      var _iterator3 = _createForOfIteratorHelper(base.set),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var parent = _step3.value;\n\n          var _iterator4 = _createForOfIteratorHelper(configs),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var config = _step4.value;\n              set.push(Modifier.get(parent, config));\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return tag;\n    }\n  }]);\n\n  return Modifier;\n}();\n\nfunction sameArray(a, b) {\n  return a.length == b.length && a.every(function (x, i) {\n    return x == b[i];\n  });\n}\n\nfunction permute(array) {\n  var result = [array];\n\n  for (var i = 0; i < array.length; i++) {\n    var _iterator5 = _createForOfIteratorHelper(permute(array.slice(0, i).concat(array.slice(i + 1)))),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var a = _step5.value;\n        result.push(a);\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  }\n\n  return result;\n} /// This function is used to add a set of tags to a language syntax\n/// via [`NodeSet.extend`](#common.NodeSet.extend) or\n/// [`LRParser.configure`](#lr.LRParser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node name](#common.NodeType.name), or\n/// multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single levelâ€”wildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all child nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": [tags.string, tags.invalid],\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\n\n\nfunction styleTags(spec) {\n  var byName = Object.create(null);\n\n  for (var prop in spec) {\n    var _tags = spec[prop];\n    if (!Array.isArray(_tags)) _tags = [_tags];\n\n    var _iterator6 = _createForOfIteratorHelper(prop.split(\" \")),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var part = _step6.value;\n\n        if (part) {\n          var pieces = [],\n              mode = 2\n          /* Normal */\n          ,\n              rest = part;\n\n          for (var pos = 0;;) {\n            if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n              mode = 1\n              /* Inherit */\n              ;\n              break;\n            }\n\n            var m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n            if (!m) throw new RangeError(\"Invalid path: \" + part);\n            pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n            pos += m[0].length;\n            if (pos == part.length) break;\n            var next = part[pos++];\n\n            if (pos == part.length && next == \"!\") {\n              mode = 0\n              /* Opaque */\n              ;\n              break;\n            }\n\n            if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n            rest = part.slice(pos);\n          }\n\n          var last = pieces.length - 1,\n              inner = pieces[last];\n          if (!inner) throw new RangeError(\"Invalid path: \" + part);\n          var rule = new Rule(_tags, mode, last > 0 ? pieces.slice(0, last) : null);\n          byName[inner] = rule.sort(byName[inner]);\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n  }\n\n  return ruleNodeProp.add(byName);\n}\n\nvar ruleNodeProp = new NodeProp();\n\nvar Rule = /*#__PURE__*/function () {\n  function Rule(tags, mode, context, next) {\n    _classCallCheck(this, Rule);\n\n    this.tags = tags;\n    this.mode = mode;\n    this.context = context;\n    this.next = next;\n  }\n\n  _createClass(Rule, [{\n    key: \"sort\",\n    value: function sort(other) {\n      if (!other || other.depth < this.depth) {\n        this.next = other;\n        return this;\n      }\n\n      other.next = this.sort(other.next);\n      return other;\n    }\n  }, {\n    key: \"depth\",\n    get: function get() {\n      return this.context ? this.context.length : 0;\n    }\n  }]);\n\n  return Rule;\n}(); /// Define a [highlighter](#highlight.Highlighter) from an array of\n/// tag/class pairs. Classes associated with more specific tags will\n/// take precedence.\n\n\nfunction tagHighlighter(tags, options) {\n  var map = Object.create(null);\n\n  var _iterator7 = _createForOfIteratorHelper(tags),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var style = _step7.value;\n      if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;else {\n        var _iterator10 = _createForOfIteratorHelper(style.tag),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var tag = _step10.value;\n            map[tag.id] = style.class;\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  var _ref = options || {},\n      scope = _ref.scope,\n      _ref$all = _ref.all,\n      all = _ref$all === void 0 ? null : _ref$all;\n\n  return {\n    style: function style(tags) {\n      var cls = all;\n\n      var _iterator8 = _createForOfIteratorHelper(tags),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var tag = _step8.value;\n\n          var _iterator9 = _createForOfIteratorHelper(tag.set),\n              _step9;\n\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var sub = _step9.value;\n              var tagClass = map[sub.id];\n\n              if (tagClass) {\n                cls = cls ? cls + \" \" + tagClass : tagClass;\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return cls;\n    },\n    scope: scope\n  };\n}\n\nfunction highlightTags(highlighters, tags) {\n  var result = null;\n\n  var _iterator11 = _createForOfIteratorHelper(highlighters),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var highlighter = _step11.value;\n      var value = highlighter.style(tags);\n      if (value) result = result ? result + \" \" + value : value;\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  return result;\n} /// Highlight the given [tree](#common.Tree) with the given\n/// [highlighter](#highlight.Highlighter).\n\n\nfunction highlightTree(tree, highlighter, /// Assign styling to a region of the text. Will be called, in order\n/// of position, for any ranges where more than zero classes apply.\n/// `classes` is a space separated string of CSS classes.\nputStyle) {\n  var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var to = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : tree.length;\n  var builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n  builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n  builder.flush(to);\n}\n\nvar HighlightBuilder = /*#__PURE__*/function () {\n  function HighlightBuilder(at, highlighters, span) {\n    _classCallCheck(this, HighlightBuilder);\n\n    this.at = at;\n    this.highlighters = highlighters;\n    this.span = span;\n    this.class = \"\";\n  }\n\n  _createClass(HighlightBuilder, [{\n    key: \"startSpan\",\n    value: function startSpan(at, cls) {\n      if (cls != this.class) {\n        this.flush(at);\n        if (at > this.at) this.at = at;\n        this.class = cls;\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush(to) {\n      if (to > this.at && this.class) this.span(this.at, to, this.class);\n    }\n  }, {\n    key: \"highlightRange\",\n    value: function highlightRange(cursor, from, to, inheritedClass, highlighters) {\n      var type = cursor.type,\n          start = cursor.from,\n          end = cursor.to;\n      if (start >= to || end <= from) return;\n      if (type.isTop) highlighters = this.highlighters.filter(function (h) {\n        return !h.scope || h.scope(type);\n      });\n      var cls = inheritedClass;\n      var rule = type.prop(ruleNodeProp),\n          opaque = false;\n\n      while (rule) {\n        if (!rule.context || cursor.matchContext(rule.context)) {\n          var tagCls = highlightTags(highlighters, rule.tags);\n\n          if (tagCls) {\n            if (cls) cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1\n            /* Inherit */\n            ) inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;else if (rule.mode == 0\n            /* Opaque */\n            ) opaque = true;\n          }\n\n          break;\n        }\n\n        rule = rule.next;\n      }\n\n      this.startSpan(cursor.from, cls);\n      if (opaque) return;\n      var mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);\n\n      if (mounted && mounted.overlay) {\n        var inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n        var innerHighlighters = this.highlighters.filter(function (h) {\n          return !h.scope || h.scope(mounted.tree.type);\n        });\n        var hasChild = cursor.firstChild();\n\n        for (var i = 0, pos = start;; i++) {\n          var next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n          var nextPos = next ? next.from + start : end;\n          var rangeFrom = Math.max(from, pos),\n              rangeTo = Math.min(to, nextPos);\n\n          if (rangeFrom < rangeTo && hasChild) {\n            while (cursor.from < rangeTo) {\n              this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n              this.startSpan(Math.min(to, cursor.to), cls);\n              if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n            }\n          }\n\n          if (!next || nextPos > to) break;\n          pos = next.to + start;\n\n          if (pos > from) {\n            this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);\n            this.startSpan(pos, cls);\n          }\n        }\n\n        if (hasChild) cursor.parent();\n      } else if (cursor.firstChild()) {\n        do {\n          if (cursor.to <= from) continue;\n          if (cursor.from >= to) break;\n          this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n          this.startSpan(Math.min(to, cursor.to), cls);\n        } while (cursor.nextSibling());\n\n        cursor.parent();\n      }\n    }\n  }]);\n\n  return HighlightBuilder;\n}();\n\nvar t = Tag.define;\nvar comment = t(),\n    name = t(),\n    typeName = t(name),\n    propertyName = t(name),\n    literal = t(),\n    string = t(literal),\n    number = t(literal),\n    content = t(),\n    heading = t(content),\n    keyword = t(),\n    operator = t(),\n    punctuation = t(),\n    bracket = t(punctuation),\n    meta = t(); /// The default set of highlighting [tags](#highlight.Tag).\n///\n/// This collection is heavily biased towards programming languages,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set. If all else\n/// fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\n/// your use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an elementâ€”if your grammar can't easily\n/// distinguish a certain type of element (such as a local variable),\n/// it is okay to style it as its more general variant (a variable).\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\n\nvar tags = {\n  /// A comment.\n  comment: comment,\n  /// A line [comment](#highlight.tags.comment).\n  lineComment: t(comment),\n  /// A block [comment](#highlight.tags.comment).\n  blockComment: t(comment),\n  /// A documentation [comment](#highlight.tags.comment).\n  docComment: t(comment),\n  /// Any kind of identifier.\n  name: name,\n  /// The [name](#highlight.tags.name) of a variable.\n  variableName: t(name),\n  /// A type [name](#highlight.tags.name).\n  typeName: typeName,\n  /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n  tagName: t(typeName),\n  /// A property or field [name](#highlight.tags.name).\n  propertyName: propertyName,\n  /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n  attributeName: t(propertyName),\n  /// The [name](#highlight.tags.name) of a class.\n  className: t(name),\n  /// A label [name](#highlight.tags.name).\n  labelName: t(name),\n  /// A namespace [name](#highlight.tags.name).\n  namespace: t(name),\n  /// The [name](#highlight.tags.name) of a macro.\n  macroName: t(name),\n  /// A literal value.\n  literal: literal,\n  /// A string [literal](#highlight.tags.literal).\n  string: string,\n  /// A documentation [string](#highlight.tags.string).\n  docString: t(string),\n  /// A character literal (subtag of [string](#highlight.tags.string)).\n  character: t(string),\n  /// An attribute value (subtag of [string](#highlight.tags.string)).\n  attributeValue: t(string),\n  /// A number [literal](#highlight.tags.literal).\n  number: number,\n  /// An integer [number](#highlight.tags.number) literal.\n  integer: t(number),\n  /// A floating-point [number](#highlight.tags.number) literal.\n  float: t(number),\n  /// A boolean [literal](#highlight.tags.literal).\n  bool: t(literal),\n  /// Regular expression [literal](#highlight.tags.literal).\n  regexp: t(literal),\n  /// An escape [literal](#highlight.tags.literal), for example a\n  /// backslash escape in a string.\n  escape: t(literal),\n  /// A color [literal](#highlight.tags.literal).\n  color: t(literal),\n  /// A URL [literal](#highlight.tags.literal).\n  url: t(literal),\n  /// A language keyword.\n  keyword: keyword,\n  /// The [keyword](#highlight.tags.keyword) for the self or this\n  /// object.\n  self: t(keyword),\n  /// The [keyword](#highlight.tags.keyword) for null.\n  null: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n  atom: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that represents a unit.\n  unit: t(keyword),\n  /// A modifier [keyword](#highlight.tags.keyword).\n  modifier: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n  operatorKeyword: t(keyword),\n  /// A control-flow related [keyword](#highlight.tags.keyword).\n  controlKeyword: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that defines something.\n  definitionKeyword: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) related to defining or\n  /// interfacing with modules.\n  moduleKeyword: t(keyword),\n  /// An operator.\n  operator: operator,\n  /// An [operator](#highlight.tags.operator) that defines something.\n  derefOperator: t(operator),\n  /// Arithmetic-related [operator](#highlight.tags.operator).\n  arithmeticOperator: t(operator),\n  /// Logical [operator](#highlight.tags.operator).\n  logicOperator: t(operator),\n  /// Bit [operator](#highlight.tags.operator).\n  bitwiseOperator: t(operator),\n  /// Comparison [operator](#highlight.tags.operator).\n  compareOperator: t(operator),\n  /// [Operator](#highlight.tags.operator) that updates its operand.\n  updateOperator: t(operator),\n  /// [Operator](#highlight.tags.operator) that defines something.\n  definitionOperator: t(operator),\n  /// Type-related [operator](#highlight.tags.operator).\n  typeOperator: t(operator),\n  /// Control-flow [operator](#highlight.tags.operator).\n  controlOperator: t(operator),\n  /// Program or markup punctuation.\n  punctuation: punctuation,\n  /// [Punctuation](#highlight.tags.punctuation) that separates\n  /// things.\n  separator: t(punctuation),\n  /// Bracket-style [punctuation](#highlight.tags.punctuation).\n  bracket: bracket,\n  /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n  /// tokens).\n  angleBracket: t(bracket),\n  /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n  /// tokens).\n  squareBracket: t(bracket),\n  /// Parentheses (usually `(` and `)` tokens). Subtag of\n  /// [bracket](#highlight.tags.bracket).\n  paren: t(bracket),\n  /// Braces (usually `{` and `}` tokens). Subtag of\n  /// [bracket](#highlight.tags.bracket).\n  brace: t(bracket),\n  /// Content, for example plain text in XML or markup documents.\n  content: content,\n  /// [Content](#highlight.tags.content) that represents a heading.\n  heading: heading,\n  /// A level 1 [heading](#highlight.tags.heading).\n  heading1: t(heading),\n  /// A level 2 [heading](#highlight.tags.heading).\n  heading2: t(heading),\n  /// A level 3 [heading](#highlight.tags.heading).\n  heading3: t(heading),\n  /// A level 4 [heading](#highlight.tags.heading).\n  heading4: t(heading),\n  /// A level 5 [heading](#highlight.tags.heading).\n  heading5: t(heading),\n  /// A level 6 [heading](#highlight.tags.heading).\n  heading6: t(heading),\n  /// A prose separator (such as a horizontal rule).\n  contentSeparator: t(content),\n  /// [Content](#highlight.tags.content) that represents a list.\n  list: t(content),\n  /// [Content](#highlight.tags.content) that represents a quote.\n  quote: t(content),\n  /// [Content](#highlight.tags.content) that is emphasized.\n  emphasis: t(content),\n  /// [Content](#highlight.tags.content) that is styled strong.\n  strong: t(content),\n  /// [Content](#highlight.tags.content) that is part of a link.\n  link: t(content),\n  /// [Content](#highlight.tags.content) that is styled as code or\n  /// monospace.\n  monospace: t(content),\n  /// [Content](#highlight.tags.content) that has a strike-through\n  /// style.\n  strikethrough: t(content),\n  /// Inserted text in a change-tracking format.\n  inserted: t(),\n  /// Deleted text.\n  deleted: t(),\n  /// Changed text.\n  changed: t(),\n  /// An invalid or unsyntactic element.\n  invalid: t(),\n  /// Metadata or meta-instruction.\n  meta: meta,\n  /// [Metadata](#highlight.tags.meta) that applies to the entire\n  /// document.\n  documentMeta: t(meta),\n  /// [Metadata](#highlight.tags.meta) that annotates or adds\n  /// attributes to a given syntactic element.\n  annotation: t(meta),\n  /// Processing instruction or preprocessor directive. Subtag of\n  /// [meta](#highlight.tags.meta).\n  processingInstruction: t(meta),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n  /// given element is being defined. Expected to be used with the\n  /// various [name](#highlight.tags.name) tags.\n  definition: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n  /// something is constant. Mostly expected to be used with\n  /// [variable names](#highlight.tags.variableName).\n  constant: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\n  /// a [variable](#highlight.tags.variableName) or [property\n  /// name](#highlight.tags.propertyName) is being called or defined\n  /// as a function.\n  function: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n  /// [names](#highlight.tags.name) to indicate that they belong to\n  /// the language's standard environment.\n  standard: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n  /// [names](#highlight.tags.name) is local to some scope.\n  local: Tag.defineModifier(),\n  /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n  /// can be used to tag language-specific alternative variants of\n  /// some common tag. It is recommended for themes to define special\n  /// forms of at least the [string](#highlight.tags.string) and\n  /// [variable name](#highlight.tags.variableName) tags, since those\n  /// come up a lot.\n  special: Tag.defineModifier()\n}; /// This is a highlighter that adds stable, predictable classes to\n/// tokens, for styling with external CSS.\n///\n/// The following tags are mapped to their name prefixed with `\"tok-\"`\n/// (for example `\"tok-comment\"`):\n///\n/// * [`link`](#highlight.tags.link)\n/// * [`heading`](#highlight.tags.heading)\n/// * [`emphasis`](#highlight.tags.emphasis)\n/// * [`strong`](#highlight.tags.strong)\n/// * [`keyword`](#highlight.tags.keyword)\n/// * [`atom`](#highlight.tags.atom)\n/// * [`bool`](#highlight.tags.bool)\n/// * [`url`](#highlight.tags.url)\n/// * [`labelName`](#highlight.tags.labelName)\n/// * [`inserted`](#highlight.tags.inserted)\n/// * [`deleted`](#highlight.tags.deleted)\n/// * [`literal`](#highlight.tags.literal)\n/// * [`string`](#highlight.tags.string)\n/// * [`number`](#highlight.tags.number)\n/// * [`variableName`](#highlight.tags.variableName)\n/// * [`typeName`](#highlight.tags.typeName)\n/// * [`namespace`](#highlight.tags.namespace)\n/// * [`className`](#highlight.tags.className)\n/// * [`macroName`](#highlight.tags.macroName)\n/// * [`propertyName`](#highlight.tags.propertyName)\n/// * [`operator`](#highlight.tags.operator)\n/// * [`comment`](#highlight.tags.comment)\n/// * [`meta`](#highlight.tags.meta)\n/// * [`punctuation`](#highlight.tags.punctuation)\n/// * [`invalid`](#highlight.tags.invalid)\n///\n/// In addition, these mappings are provided:\n///\n/// * [`regexp`](#highlight.tags.regexp),\n///   [`escape`](#highlight.tags.escape), and\n///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n///   are mapped to `\"tok-string2\"`\n/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName2\"`\n/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-local\"`\n/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-definition\"`\n/// * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n///   to `\"tok-propertyName tok-definition\"`\n\nvar classHighlighter = tagHighlighter([{\n  tag: tags.link,\n  class: \"tok-link\"\n}, {\n  tag: tags.heading,\n  class: \"tok-heading\"\n}, {\n  tag: tags.emphasis,\n  class: \"tok-emphasis\"\n}, {\n  tag: tags.strong,\n  class: \"tok-strong\"\n}, {\n  tag: tags.keyword,\n  class: \"tok-keyword\"\n}, {\n  tag: tags.atom,\n  class: \"tok-atom\"\n}, {\n  tag: tags.bool,\n  class: \"tok-bool\"\n}, {\n  tag: tags.url,\n  class: \"tok-url\"\n}, {\n  tag: tags.labelName,\n  class: \"tok-labelName\"\n}, {\n  tag: tags.inserted,\n  class: \"tok-inserted\"\n}, {\n  tag: tags.deleted,\n  class: \"tok-deleted\"\n}, {\n  tag: tags.literal,\n  class: \"tok-literal\"\n}, {\n  tag: tags.string,\n  class: \"tok-string\"\n}, {\n  tag: tags.number,\n  class: \"tok-number\"\n}, {\n  tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n  class: \"tok-string2\"\n}, {\n  tag: tags.variableName,\n  class: \"tok-variableName\"\n}, {\n  tag: tags.local(tags.variableName),\n  class: \"tok-variableName tok-local\"\n}, {\n  tag: tags.definition(tags.variableName),\n  class: \"tok-variableName tok-definition\"\n}, {\n  tag: tags.special(tags.variableName),\n  class: \"tok-variableName2\"\n}, {\n  tag: tags.definition(tags.propertyName),\n  class: \"tok-propertyName tok-definition\"\n}, {\n  tag: tags.typeName,\n  class: \"tok-typeName\"\n}, {\n  tag: tags.namespace,\n  class: \"tok-namespace\"\n}, {\n  tag: tags.className,\n  class: \"tok-className\"\n}, {\n  tag: tags.macroName,\n  class: \"tok-macroName\"\n}, {\n  tag: tags.propertyName,\n  class: \"tok-propertyName\"\n}, {\n  tag: tags.operator,\n  class: \"tok-operator\"\n}, {\n  tag: tags.comment,\n  class: \"tok-comment\"\n}, {\n  tag: tags.meta,\n  class: \"tok-meta\"\n}, {\n  tag: tags.invalid,\n  class: \"tok-invalid\"\n}, {\n  tag: tags.punctuation,\n  class: \"tok-punctuation\"\n}]);\nexport { Tag, classHighlighter, highlightTree, styleTags, tagHighlighter, tags };","map":null,"metadata":{},"sourceType":"module"}